
* Simple Rollup Model [no forced queue, no blacklist, no upgrades]
** Mechanism
- The state of L2 is stored on L1 and includes:
  [TODO]
- Commitment and Proof objects are associated with some L2 state and
include a block which corresponds to the new transition
*** Subtleties
- process commitments and proofs transition at a time
cannot finalize state which is more than one transition away
** Properties
  + at most one event [design of the system]
  + if something gets finalized then there was 
    a proof and a commitment for it at some moment in the past
  + finalized state grows monotonically
  + [new] if commitment and proof are accepted then they agree and they
    are associated with the current state
  + [new] only one commitment/proof per state is finalized
  + [new] every next block adds exactly one block (transition) to the state

  - no way to force Input, input might stay non-finalized forever
  - commitment and proof exists but not getting processed
** Scenarios
  - start with empty finalized state and progress to multiple blocks
  - produce two different commitment/proof pairs for the same state, finalize one [other is never finalized]
  - receive proof and commitment in different order
  - receive longer proof/comm and then shorter, finalize both
  - finalize same input multiple times
** Possible extensions
  - introduce data availability and data expiration (DA)
  - more finegrained process
  - state diffs vs inputs
  - associated finalized state with hashes and not actual blocks
* Forced Queue [Cold Rollup]
** Mechanism
  - L2 state on L1 includes ~forced_queue~ which is a sequence
    of elements of type ~ForcedEvent~. ~ForcedInput~ is a subtype of ~ForcedEvent~
  - new query ~receive_forced[f : ForcedEvent]~ 
  - if ~forced_queue~ is empty then proceed as before
  - if ~forced_queue~ is not empty then every new finalized block needs to have
    head of the input and possibly other transactions from the queue
  - most importantly the remaining elements has to move to the head of the queue and
    their relative positions must not change

*** Subtleties
- inputs must only be removed from forced queue when their are 
immutably finalized
- the head of the input has to be processed 
- relative positions must be preserved
- new inputs can only be added to the end of the queue

** Properties
  + if ~forced_queue~ is non-empty and something was added to the finalized-state
    then the head of the forced queue was processed
  + if finalized state didn't change then ~forced_queue~ only increased
  + if ~forced_queue~ is not empty and didn't change then ~finalized_state~ didn't change
  + forced txs which were not processed move down in the forced queue
  + [new] if input was in the forced queue and then disappeared from it then
     it was finalized
  + [new] after ~forced_queue~ always has a head (i.e., element at position 0)
  + [new] if input is in the ~forced_queue~ and it was in the finalized block then it disappeared
     from the forced_queue

  + [new] relative positions are always preserved
** Scenarios
  - finalize forced queue in one go
  - finalize forced queue one input at a time
  - process forced queue elements out of order
  - normally process elements with forced queue being empty
  - process some elements, add inputs to forced queue, process all of them,
    process more
  - input appears in the end of the forced_queue and jumps to the first head position
    in the next round
  - finalized input is added to the forced queue and then processed
  - More?
** Possible extensions
- Exodus mechanism: when forced queue did not change for a long time (timeout)
  then proccess only forced queue [and system dies afterwards]
  
* Forced Queue + Eager Blacklisting Policy
** Mechanism
  - extend ~ForcedEvent~ with ~ForcedBlaklistPolicy~ which includes subset of inputs
  - state of L2 on L1 has explicit set of blacklisted inputs (~blacklist~)
  - ForcedBlacklist policy is also added to the end of the forced queue
  - when the forced blacklist policy is in the head of the queue it is deployed
  - forced transactions which follow new policy must respect it
    otherwise the system gets frozen
  - rollup processing must reject a block if its inputs are currently blacklisted
  - if forced queue does not contain new blacklisting policy then it respects the currently
    active one; otherwise it respects the new queued policy
  - forced queue can only contain a single ForcedBlacklistPolicy at a
    time otherwise gets messy

Questions:
  Do we respect queued forced policy for processed inputs (which are not in the forced queue)?

*** Subtleties
  - this blacklisting strategy is the most aggressive one which is
    compatible with the forced queue operation
  - if the new policy in the forced queue is not respected then system gets frozen
  - it is a choice whether we respect currently active blacklisting policy ~L1.blacklist~
    or the one which is in the forced queue. The first option gives cleaner properties.
  - ???
** Properties
   - If block is finalized then it does not containt blacklisted inputs
   - if input got forced and there is no queued blacklisting policy
     then the input is not in the ~L1.blacklist~
   - if input got forced and there is queued blacklisting policy
     then the input is not in it
   - if there is a blacklisted input in the head of the queue then rollup is frozen
   - blacklisted input can never appear in the head of the queue
   - if input is not blacklisted and could be processed according to the system with
     no blacklisting policies then it can be processed in the system with the blacklisting policy
   - same as above but for forced_queue
   - if everything is blacklisted then system does not progress
   - all forced inputs behind forced policy respect it
   - ???
** Scenarios
   - currently non-blacklisted input gets blacklisted
   - currently blacklisted input gets non-blacklisted
   - currently blacklisted input gets in the forced queue
   - currently blacklisted input gets finalized
   - non finalized input which is blacklisted by queued forced policy gets finalized
   - forced input and blacklist in the forced queue and forced input
     is blacklisted by the new policy [in this case forced input is always
     in front of the policy]
   - ???

** Possible extensions
  - instead of only blacklisting Inputs allow also to blacklist ~ForcedEvents~.
    This gives very fine-grained control over operation of the forced queue.
    For example, one can blacklist ForcedInputs, ForcedBlacklist policies, or ForcedUpgrades
  - Observe that the described blacklisting mechanism is very agressive -- policy is active
    from the moment it is forced queued. In the following we develop upgradeability mechanism and instatiate
    it for updating the blacklisting policy
* Forced Queue + Upgradeability [instantiated for soft blacklisting policy]
** Mechanism
[TODO]
Questions:
   - upgrade_in_progress: keep processing -- good because of DDOS
   - during upgrade_queue_processing -- do we accept all TX or only forced ones
** Properties
   - The policy can only change if there was upgrade before
   - If L1.ongoing_upgrade is set iff upgrade is ongoing
   - if upgrade_queue_progressing then forced_queue does not accept new forced transactions
   - after upgrade is finished then new policy is enforced
   - until upgrade is finished the blacklisting policy is not changed
   - after upgrade is finished all force inputs transactions are finalized
   - state machine description
      upgrade_init
      
** Scenarios
   - upgrade finished then accept new forced queue
   - transactions get finalized during upgrade phases
   - transactions get queued before the timeout
   - upgrade starts ; forced transactions appear ; upgrade finished

* Extensions (Future Work)
   - L2 model (fast/slow vm, sequencer)
   - Reorgs (relevant for L2?)
   - DA and expiration (Celestia collaboration?)
   - preconfirmations on L2 (?)
   - More?
